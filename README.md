### Android studio 动态链接库生成及使用

##### 一、创建需要的类、方法

```java
package com.zsrun.jnidemo;

public class MyJniDemo {

    public static native String getString();

    public static native int add(int a, int b);

}
```

##### 二、生成class 文件

​	Make Project编译项目，生成.class文件  

​	class文件目录 ： build / intermediates / javac / debug / 对应包名下

##### 三、生成.h文件

1. 在app/src/main下新建一个jni文件夹

2. 终端进入jni目录 

3. javah 生成.h文件

   ```visual basic
   javah -d jni -classpath E:work\xx\xx\xx com.zsrun.jnidemo.MyJniDemo  //生成.h文件需要绝对路径
   ```

   执行成功后会在jni目录下生成.h文件

   ```h
   /* DO NOT EDIT THIS FILE - it is machine generated */
   #include <jni.h>
   /* Header for class com_zsrun_jnidemo_MyJniDemo */
   
   #ifndef _Included_com_zsrun_jnidemo_MyJniDemo
   #define _Included_com_zsrun_jnidemo_MyJniDemo
   #ifdef __cplusplus
   extern "C" {
   #endif
   /*
    * Class:     com_zsrun_jnidemo_MyJniDemo
    * Method:    getString
    * Signature: ()Ljava/lang/String;
    */
   JNIEXPORT jstring JNICALL Java_com_zsrun_jnidemo_MyJniDemo_getString
     (JNIEnv *, jclass);
   
   /*
    * Class:     com_yxkj_jnidemo_MyJniDemo
    * Method:    add
    * Signature: (II)I
    */
   JNIEXPORT jint JNICALL Java_com_zsrun_jnidemo_MyJniDemo_add
     (JNIEnv *, jclass, jint, jint);
   
   #ifdef __cplusplus
   }
   #endif
   #endif
   ```

##### 四、编写.c文件​

1. 新建xxx.c 文件  （名称随意）

2. 引入生成的.h文件

3. 拷贝.h文件中生成的方法体至xxx.c

   ```c
   //自己创建的c文件，实现自己定义的native方法，生成的.h文件中的方法
   //引入自己生成的.h文件
   #include <com_zsrun_jnidemo_MyJniDemo.h>
   
   //返回一个字符串
   JNIEXPORT jstring JNICALL Java_com_zsrun_jnidemo_MyJniDemo_getString
     (JNIEnv * env, jclass obj){
       return (*env)->NewStringUTF(env,"这是我用jni调用出来的字符串");
     }
   
   
   //返回a+b的结果
   JNIEXPORT jint JNICALL Java_com_zsrun_jnidemo_MyJniDemo_add
     (JNIEnv * env, jclass obj, jint a, jint b){
       return a+b;
     }
   ```

4. 注意点

   因为.h文件中的方法，部分参数被省略，在.c文件中需要加上，否则会报”parameter name omitted“的错误

##### 五、编写Android.mk 、Application.mk文件

1. 编写Android.mk文件

   ```c
   LOCAL_PATH:=$(call my-dir)
   include $(CLEAR_VARS)
   
   LOCAL_MODULE := MyDemo
   LOCAL_SRC_FILES := Hello_jni.c
   
   include $(BUILD_SHARED_LIBRARY)
   ```

   > `LOCAL_PATH := $(call my-dir)`：每个Android.mk文件必须以定义开始。它用于在开发tree中查找源文件。宏`my-dir`则由Build System 提供。返回包含Android.mk目录路径。
   >
   >  `include $(CLEAR_VARS)` ：`CLEAR_VARS`变量由Build System提供。并指向一个指定的GNU Makefile，由它负责清理很多LOCAL_xxx。例如LOCAL_MODULE，LOCAL_SRC_FILES，LOCAL_STATIC_LIBRARIES等等。但不是清理LOCAL_PATH。这个清理是必须的，因为所有的编译控制文件由同一个GNU Make解析和执行，其变量是全局的。所以清理后才能便面相互影响。
   >
   >  `LOCAL_MODULE := MyDemo`：LOCAL_MODULE模块必须定义，以表示Android.mk中的每一个模块。名字必须唯一且不包含空格。Build System 会自动添加适当的前缀和后缀。例如，demo，要生成动态库，则生成libdemo.so。但请注意：如果模块名字被定义为libabd，则生成libabc.so。不再添加前缀。
   >
   >  `LOCAL_SRC_FILES := Hello_jni.c`：这行代码表示将要打包的C/C++源码。不必列出头文件，build System 会自动帮我们找出依赖文件。缺省的C++ 源码的扩展名为.cpp。
   >
   > ```
   > include $(BUILD_SHARED_LIBRARY):BUILD_SHARED_LIBRARY
   > ```
   >
   > 是Build System提供的一个变量，指向一个GUN Makefile Script。它负责收集自从上次调用include $(CLEAR_VARS)后的所有LOCAL_xxxxinx。并决定编译什么类型 
   >
   > -  `BUILD_STATIC_LIBRARY`：编译为静态库
   > -  `BUILD_SHARED_LIBRARY`：编译为动态库
   > -  `BUILD_EXECUTABLE`：编译为Native C 可执行程序
   > -  `BUILD_PREBUILT`：该模块已经预先编译

2. 编写Application.mk文件

   ```c
   APP_PLATFORM := android-14
   
   APP_ABI := all //表示生成所有类型的so文件
   ```

##### 六、生成so库

1. 配置NDK环境

   1. 检查local.properties 文件中是否配置ndk路径

      ```
      ndk.dir=G\:\\gameSDK\\android-ndk-r16b
      ```

   2. 检查gradle.properties 中是否添加ndk配置

      ```
      android.useDeprecatedNdk=true
      ```

   3. 配置build.gradle文件

      ```groovy
      android {
          compileSdkVersion 28
          defaultConfig {
              applicationId "com.zsrun.jnidemo"
              minSdkVersion 15
              targetSdkVersion 28
              versionCode 1
              versionName "1.0"
              testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
      
              //NDK 配置
              ndk {
                  moduleName "MyDemo"//指定生成的so文件名，后期调用时的名字
                  abiFilters "armeabi", "armeabi-v7a", "x86"//cpu的类型
              }
          }
          
          sourceSets {
              main {
                  jni.srcDirs = ['libs']
              }
          }
      }
      ```

   4. 生成so库

      终端进入main文件夹  命令 ： ndk-build  即可生成so文件

##### 七、使用so库，调用方法

1. 加载so库

   ```java
   static {
       System.loadLibrary("MyDemo");//名称与生成so库时的名称一致
   }
   ```

2. 调用方法

   ```java
   textView = findViewById(R.id.test);
   textView.setText(MyJniDemo.getString());//掉用获取String字符串的方法
   
   textView.append("\n");
   textView.append(String.valueOf(MyJniDemo.add(5, 99)));//调用两个int类型相加的方法
   ```

##### 八、相关文章

​	[Android NDK与JNI 基础](https://www.jianshu.com/p/87ce6f565d37)

​	[NDK本地编程](https://www.cnblogs.com/rocomp/p/4892866.html)